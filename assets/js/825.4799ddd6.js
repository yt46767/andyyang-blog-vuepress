(window.webpackJsonp=window.webpackJsonp||[]).push([[825],{921:function(r,a,n){"use strict";n.r(a);var e=n(7),t=Object(e.a)({},(function(){var r=this,a=r._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[a("h2",{attrs:{id:"二叉树-递归算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二叉树-递归算法"}},[r._v("#")]),r._v(" 二叉树-递归算法")]),r._v(" "),a("p",[r._v("例：给定 id 在 data 里的路径")]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("const data = { // 模拟的antd的树结构数据，以ID作为唯一指定值\n            key: '1',\n            id: 'asascascasc',\n            children: [\n                {\n                    key: '1.1',\n                    id: 'asvasvgasf',\n                    children: [\n                        {\n                            key: '1.1.1',\n                            id: '8888',\n                            children: [],\n                        },\n                    ],\n                },\n                .....\n            ],\n        }\n        const getPosByIdInTree = (tree, id) => {\n            const tmp = [] // 路径数组\n\t\t\tif(tree.id === id) {return [0]}//根节点\n\t\t\t\n            const FindPos = (sourceTree, sourceId) => {\n                if (!sourceTree.children) {\n                    return; // 为末端节点\n                }\n                sourceTree.children.forEach((item, index) => {\n                    if (item.id === sourceId) {// 寻找到指定的元素节点\n                        tmp.push(index);\n                        FindPos(tree, sourceTree.id) // 继续寻找下一层元素的位置\n                    } else {// 当前继续寻找别的子项\n                        FindPos(item, sourceId)\n                    }\n                })\n            }\n            FindPos(tree, id);\n           // return tmp\n           // 这里会有一些特定的问题,这个路径是反序存储的，所以需要存进去之后反转一次\n           // 另外看自己的需求，这个是否需要push(0)作为根节点的判定\n            return tmp.reverse()\n        }\n        const source = 'sdarqafascavf2'\n        const pos = getPosByIdInTree(data, source)\n        console.log( pos);// [3, 2, 0] 不算根节点，测试通过\n")])])]),a("p",[r._v("https://blog.csdn.net/weixin_43654374/article/details/106820913")]),r._v(" "),a("h2",{attrs:{id:"排序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#排序"}},[r._v("#")]),r._v(" 排序")]),r._v(" "),a("ul",[a("li",[a("p",[a("strong",[r._v("冒泡排序（"),a("em",[r._v("Bubble Sort")]),r._v("）")])]),r._v(" "),a("p",[r._v("O(n^2)")]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("function compareFn (a, b) {\n    return (a - b) > 0;\n}\nconst bubbleSort = function (arrayData, compareFn) {\n    let len = arrayData.length;\n    for (let i = len - 1; i > 0; i--) {\n        for (let j = 0; j < i; j++) {\n            if (compareFn(arrayData[j], arrayData[j + 1])) {\n                [arrayData[j], arrayData[j + 1]] = [arrayData[j + 1], arrayData[j]];\n            }\n        }\n    }\n}\n\n")])])]),a("p",[r._v("关键：")]),r._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("strong",[r._v("第一层遍历")]),r._v("，"),a("strong",[r._v("倒过来遍历")])]),r._v(" "),a("li",[a("strong",[r._v("第二层遍历")]),r._v("，顺着遍历，但"),a("strong",[r._v("j值不超过上一层遍历的i值")])]),r._v(" "),a("li",[r._v("前后数字对比，"),a("strong",[r._v("前大过后，调换位置")])])])]),r._v(" "),a("li",[a("p",[a("strong",[r._v("快速排序（quick sort）O(n*logn)")])]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("function compareFn (a, b) {\n    return (a - b) > 0;\n}\nfunction getMid (arrayData) {\n    return arrayData[0];\n}\nconst quickSort = function (arrayData, compareFn, getMidFn) {\n    let len = arrayData.length;\n    if (len < 2) {\n        return arrayData;\n    }\n    let mid = getMidFn(arrayData);\n    let smallGroup = [];\n    let largeGroup = [];\n    let midGroup = [];\n    for (let i = 0; i < len; i++) {\n        if (compareFn(mid, arrayData[i])) {\n            smallGroup.push(arrayData[i]);\n        } else if (compareFn(arrayData[i], mid)) {\n            largeGroup.push(arrayData[i]);\n        } else {\n            midGroup.push(arrayData[i]);\n        }\n    }\n    return [...quickSort(smallGroup, compareFn, getMidFn), ...midGroup, ...quickSort(largeGroup, compareFn, getMidFn)];\n}\n")])])]),a("p",[r._v("关键：")]),r._v(" "),a("ol",[a("li",[a("strong",[r._v("从数组里随便找出一个值")]),r._v("，这里叫：取出值")]),r._v(" "),a("li",[r._v("新建小数值数组、大数值数组、中间数值数组")]),r._v(" "),a("li",[a("strong",[r._v("一层遍历")]),r._v("，与取出值作对比，"),a("strong",[r._v("小的放进 小数值数组，大的放进 大数值数组，相同的放进 中间数值数组")])])])]),r._v(" "),a("li",[a("p",[a("strong",[r._v("归并排序（nlogn）")]),r._v("（略）")])]),r._v(" "),a("li",[a("p",[r._v("哪种排序更优？")])])]),r._v(" "),a("p",[r._v("​\t"),a("strong",[r._v("快速排序")]),r._v(" 允许用户"),a("strong",[r._v("自定义取中间值")]),r._v("的方法，可以"),a("strong",[r._v("结合实际情况")]),r._v("，更好的提升排序效率。")]),r._v(" "),a("p",[r._v("https://www.bilibili.com/read/cv9116444/?ivk_sa=1024320u")]),r._v(" "),a("h2",{attrs:{id:"全排列组合算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全排列组合算法"}},[r._v("#")]),r._v(" 全排列组合算法")]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("let func = (arr) => {\n  let len = arr.length\n  let res = [] // 所有排列结果\n  /**\n   * 【全排列算法】\n   * 说明：arrange用来对arr中的元素进行排列组合，将排列好的各个结果存在新数组中\n   * @param tempArr：排列好的元素\n   * @param leftArr：待排列元素\n   */\n  let arrange = (tempArr, leftArr) => {\n    if (tempArr.length === len) { // 这里就是递归结束的地方\n      // res.push(tempArr) // 得到全排列的每个元素都是数组\n      res.push(tempArr.join('')) // 得到全排列的每个元素都是字符串\n    } else {\n      leftArr.forEach((item, index) => {\n        let temp = [].concat(leftArr)\n        temp.splice(index, 1)\n        // 此时，第一个参数是当前分离出的元素所在数组；第二个参数temp是传入的leftArr去掉第一个后的结果\n        arrange(tempArr.concat(item), temp) // 这里使用了递归\n      })\n    }\n  }\n  arrange([], arr)\n  return res\n}\nconsole.log('结果：', func(['A', 'B', 'C', 'D']))\n")])])]),a("p",[r._v("0:")]),r._v(" "),a("p",[r._v("arrange([],[1,2,3,4])  往下走：")]),r._v(" "),a("p",[r._v("arrange([1],[2,3,4])  arrange([2],[1,3,4]) arrange([3],[1,2,4]) arrange([4],[1,2,3])")]),r._v(" "),a("p",[r._v("1:")]),r._v(" "),a("p",[r._v("arrange([1],[2,3,4])  往下走：")]),r._v(" "),a("p",[r._v("arrange([1,2],[3,4])  arrange([1,3],[2,4])  arrange([1,4],[2,3])")]),r._v(" "),a("p",[r._v("2:")]),r._v(" "),a("p",[r._v("arrange([2],[1,3,4])  往下走：")]),r._v(" "),a("p",[r._v("arrange([2,1],[3,4])  arrange([2,3],[1,4])  arrange([2,4],[1,3])")]),r._v(" "),a("p",[r._v("3:")]),r._v(" "),a("p",[r._v("arrange([3],[1,2,4])  往下走：")]),r._v(" "),a("p",[r._v("arrange([3,1],[2,4])  arrange([3,2],[1,4])    arrange([3,4],[1,2])")]),r._v(" "),a("p",[r._v("4:")]),r._v(" "),a("p",[r._v("arrange([4],[1,2,3])  往下走：")]),r._v(" "),a("p",[r._v("arrange([4,1],[2,3])  arrange([4,2],[1,3])   arrange([4,3],[1,2])")]),r._v(" "),a("p",[r._v("1.2")]),r._v(" "),a("p",[r._v("arrange([1,2],[3,4]) 往下走：")]),r._v(" "),a("p",[r._v("arrange([1,2,3],[4])  arrange([1,2,4],[3])")]),r._v(" "),a("p",[r._v("1.3")]),r._v(" "),a("p",[r._v("arrange([1,3],[2,4]) 往下走：")]),r._v(" "),a("p",[r._v("arrange([1,3,2],[4])  arrange([1,3,4],[2])")]),r._v(" "),a("p",[r._v("1.4")]),r._v(" "),a("p",[r._v("arrange([1,4],[2,3]) 往下走：")]),r._v(" "),a("p",[r._v("arrange([1,4,2],[3])  arrange([1,4,3],[2])")]),r._v(" "),a("p",[r._v("1.2.3")]),r._v(" "),a("p",[r._v("arrange([1,2,3],[4]) 往下走：")]),r._v(" "),a("p",[r._v("arrange([1,2,3,4],[])")]),r._v(" "),a("p",[r._v("1.2.4")]),r._v(" "),a("p",[r._v("arrange([1,2,4],[3])   往下走：")]),r._v(" "),a("p",[r._v("arrange([1,2,4,3],[])")]),r._v(" "),a("p",[r._v("1.3.2")]),r._v(" "),a("p",[r._v("arrange([1,3,2],[4])   往下走：")]),r._v(" "),a("p",[r._v("arrange([1,3,2,4],[])")]),r._v(" "),a("p",[r._v("1.3.4")]),r._v(" "),a("p",[r._v("arrange([1,3,4],[2])   往下走：")]),r._v(" "),a("p",[r._v("arrange([1,3,4,2],[])")]),r._v(" "),a("p",[r._v(".........")]),r._v(" "),a("p",[r._v("https://blog.csdn.net/qq_32682301/article/details/108361463")]),r._v(" "),a("h2",{attrs:{id:"算法题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#算法题"}},[r._v("#")]),r._v(" 算法题")]),r._v(" "),a("ul",[a("li",[a("p",[r._v("输出给定数字"),a("strong",[r._v("下一个比它大")]),r._v("的数字，比如输入1234，输出1243，比如1243，输出1324")]),r._v(" "),a("p",[r._v("解答原理：")]),r._v(" "),a("ol",[a("li",[a("p",[r._v("把"),a("strong",[r._v("1234拆成数组")])])]),r._v(" "),a("li",[a("p",[r._v("用"),a("strong",[r._v("全排列组合算法")]),r._v("，列出[1,2,3,4]的所有排列组合")])]),r._v(" "),a("li",[a("p",[r._v("给[1,2,3,4]的所有排列组合，用冒泡排序从小到大排序")])]),r._v(" "),a("li",[a("p",[r._v("用indexOf找出目标元素，+1等出下一个比他大的元素的索引")])])]),r._v(" "),a("p",[r._v("参考答案（java语言作答）：http://t.zoukankan.com/shuimuzhushui-p-12876512.html")])])])])}),[],!1,null,null,null);a.default=t.exports}}]);